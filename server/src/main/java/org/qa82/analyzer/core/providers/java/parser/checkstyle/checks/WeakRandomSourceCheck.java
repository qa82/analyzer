package org.qa82.analyzer.core.providers.java.parser.checkstyle.checks;

import com.google.common.collect.Lists;
import com.puppycrawl.tools.checkstyle.api.Check;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FullIdent;

import javax.management.RuntimeErrorException;
import java.io.File;
import java.util.Collection;

import static com.puppycrawl.tools.checkstyle.api.TokenTypes.*;

/**
 * An exemplary Checkstyle-Check searching for usages of cryptographic weak pseudo-random number generators.
 *
 * @author Max Vogler, Karlsruhe Institute of Technology, Germany
 */
public class WeakRandomSourceCheck extends Check {

    private static final Collection<String> UNSAFE_TYPES = Lists.newArrayList(
            "java.util.Random",
            "java.lang.Math.random",
            "Math.random"
    );

    private static final int[] DEFAULT_TOKENS = new int[] {
            IMPORT,
            STATIC_IMPORT,
            LITERAL_NEW,
            METHOD_CALL
    };

    private static final String MESSAGE = "Numbers generated by java.util.Random and java.lang.Math.random() are not " +
            "cryptographically secure and unsuitable for security-sensitive applications.";

    @Override
    public void visitToken(DetailAST ast) {
        FullIdent type = null;

        switch (ast.getType()) {
            case IMPORT:
            case METHOD_CALL:
            case LITERAL_NEW:
                type = FullIdent.createFullIdentBelow(ast);
                break;

            case STATIC_IMPORT:
                type = FullIdent.createFullIdent(ast.getFirstChild().getNextSibling());
                break;

            default:
                throw new RuntimeException("Invalid AST type: " + ast.getType());
        }

        // debug(ast, imp, isUnsafeType(type));

        if (isUnsafeType(type)) {
            log(ast.getLineNo(), ast.getColumnNo(), MESSAGE, type.getText());
        }
    }

    protected boolean isUnsafeType(FullIdent type) {
        return getUnsafeTypes().stream().anyMatch(type.getText()::startsWith);
    }

    protected Collection<String> getUnsafeTypes() {
        return UNSAFE_TYPES;
    }

    @Override
    public int[] getDefaultTokens() {
        return DEFAULT_TOKENS;
    }

    protected void debug(DetailAST ast, FullIdent fi, boolean illegal) {
        String file = new File(getFileContents().getFilename()).getName();
        String desc = file + "#" + ast.getLineNo() + " " +
                fi.getText();

        if (illegal) {
            desc += " (ILLEGAL)";
        }

        System.out.println(desc);
    }

}
